import math
from Numeric import *
from arrayfns import interp
import copy

def loadCol(file,n):
    ''' carica da un file l'n-sima colonna, restituisce lista
    di liste di valori letti (una per ogni blocco di dati) '''
    f=open(file,"r")
    lin=f.readlines()
    i=0
    area = [[]]
    flag = False
    #print area
    for l in lin:
        if l.strip()=="":
            if flag:
                i=i+1
                flag=False
            else:
                flag=True
                area.append([])
        else:
            area[i].append(float(l.split()[n-1]))            
    f.close()
    #area.pop()
    return area

def arrPr(array, nel=3):
    print "len: %s\nelements:%s,...,%s"%(len(array),array[:nel],array[-nel:])

def interpola (xsource,ysource,xtarget):
    '''dati vettori x e y e vettore xtarget delle ascisse per cui si vogliono
    valori della y interpolata, restuisce il vettore delle y interpolate'''
    #indici=[[i<target for i in xsource].count(True) for target in xtarget]
    #y=[]
    #for i,e in enumerate(xtarget):
    #    j=indici[i]
    #    y.append(ysource[j]+(e-xsource[j])*(ysource[j+1]-ysource[j])/(xsource[j+1]-xsource[j]))
    #return y
    res = interp(ysource,xsource,xtarget)
    return res
    

    
def searchByVal(d,val):
    '''restituisce la prima chiave trovata con valore val, restituisce None
    se non la trova'''
    for k,v in d.items():
        if v==val:return k
    return None

def sortByVal(d):
    '''restituisce due liste chiavi e valori delle chiavi e valori di d
    ordinate in base ai valori'''
    dd=d.copy()
    v=d.values()
    v.sort()
    k=[]
    for vv in v:
        a=searchByVal(d,vv)
        k.append(a)
        del d[a]     
    return k,v
    
    
def ciclazza (possibilita, indici, base=None):
    '''data una lista possibilita di liste di elementi tra cui scegliere, restituisce
    tutte le possibili scelte ciclando sugli indici nella tupla indici.
    per gli elementi non ciclati usa i valori in base. Senza base usa 0, mentre
    passando possibilita come base li lascia immutati'''
    
    combs=[]
    indici=tuple(indici)
    if base==None:
        b=[[0]*(len(possibilita))]
    else:
        b=[base]
    for i in indici:
        for bb in b:                    #print "ricavo nuovi valori da bb ",bb
            for x in possibilita[i]:
                bbb=bb[:]
                bbb[i]=x                #print "aggiungo ",bbb," a combs: ",combs
                combs.append(bbb)
            b=combs[:]
        combs=[]
    return b

'''eucDist,distanceTable e QTclust copiate dalle versioni in pythonAnalyzer '''
def eucDist(p1,p2):
    '''demenziale distanza euclidea'''
    if isinstance(p1,float):
        p1=[p1]
    if isinstance(p2,float):
        p2=[p2]
    if len(p1)<>len(p2): raise "different len p1p2"
    d=0
    for i in range(len(p1)):
        d=d+(p1[i]-p2[i])**2
    d=math.sqrt(d)
    return d

defaultDist=eucDist

def distanceTable(pList,dist=defaultDist):
    '''da una lista di punti pList, crea la tabella delle distanze con
    la distanza dist'''
    ndim=len(pList)
    t=[dist(u,v) for u in pList for v in pList]
    t=resize(t,(ndim,ndim))
    return t

def QTclust(puntiDic,Dmax,distance=defaultDist):
    '''puntiDic e' un dizionario con indice come chiave e valori su cui calcolare
    la distanza distance. Dmax e' il raggio massimo del cluster.
    restituisce una lista di liste ognuna delle quali e' un gruppo di indici che
    formano un cluster. usa algoritmo "quality threshold clustering (QTclust)"
    in caso di cluster candidati con stesso numero di membri sceglie quello di raggio
    minore'''

    def clustRad(cc,n,disTab):
        '''dato un candidato cluster cc e l'indice n di un punto nella tavola delle
        distanze disTab, restituisce la massima distanza del punto n da ogni punto del
        cluster.'''
        SelCol=choose(cc,disTab[n])
        m=reduce(maximum,SelCol)
        return m

    punti=puntiDic.copy()    
    np=len(punti)
    p=[v for v in punti.values()] #p e' una lista con i valori
    k=[v for v in punti.keys()] #k con le chiavi
    disTab=distanceTable(p,distance)
    clusterList=[]
    max_ccm=0
    minrad=0
    for j in range(np):
        cc=[] #candidate cluster
        ccrad=0
        col=disTab[j]
        interestArg= nonzero(less(col,Dmax))    #array di indici di valori che possono essere presi in considerazione
        if len(interestArg)<max_ccm:          #e' il massimo numero teorico di membri per questo cluster
            continue     #se meno di quelli del miglior cluster candidato..
        #crea un nuovo array solo con i valori da considerare, interestArg tiene conto della corrispondenza
        #con l'array originario
        interestVal= compress(less(col,Dmax),col) #array di valori che possono essere presi in considerazione
        sv=argsort(interestVal) #indici ordinati dal piu' piccolo al + grande

        #crea cluster candidato
        cc.append(j)
        for cp in sv[1:]:
            cpArg=interestArg[cp]   #cpArg indice corrispondente nel vettore punti
            cr=clustRad(cc,cpArg,disTab)
            if cr<=Dmax:
                cc.append(interestArg[cp])
                if cr>ccrad:ccrad=cr
        ccm=len(cc)

        #decide se e' il candidato migliore finora trovato
        if ccm>max_ccm or (ccm==max_ccm and ccrad<minrad):
            max_ccm=ccm
            ccc=cc
            minrad=ccrad
            #potrebbe celare ambiguita', cluster con stesso numero di membri,ma membri diversi e
            #stesso raggio, non garantisce unicita' del risultato
    clusterList.append([k[i] for i in ccc])
    for i in ccc: del punti[k[i]]
    if len(punti)<>0: clusterList.extend(QTclust(punti,Dmax,distance))
    return clusterList
            
      