import numpy as np
from matplotlib import pyplot as plt
import math
from scipy import interpolate as ip
from numpy import ma
import os


"""2014/03/17 moved here all routines from EA2019_align and from OP1S07_align."""

"""2014/03/06 from v1. Start from nanovea txt files use pure python to avoid coordinates mess. Assume data are saved with y fast axis and +,+ scanning
directions. It is not guaranteed to work with different scanning directions."""

"""angpos copiata qui, che non so come si fa ad importare in questo casino di directories. 
CHANGES: angpos e' stata corretta funzionava con dati trasposti"""
    
def _angpos2(xy):
    '''given an image and some notable points, return the angular positions of points with respect to barycenter'''
    #N xy points are expressed as array N x 2
    b=(np.sum(xy,0))/(xy.shape[0])    #calculate barycenter
    deltaxy=xy-(b.repeat(xy.size/2).reshape(2,-1)).T
    r=np.sqrt(np.sum(deltaxy**2,1))
    theta=np.arctan2(deltaxy[:,1],deltaxy[:,0])
    return theta,r,b

def rotate_points(points,theta,center=(0,0)):
    """returns rotated coordinates of 2D point(s) x ([Npoints x 2]) about a center with anticlockwise angle theta in rad. If 3D points are passed, z coordinate is maintained."""
    tx,ty=center
    if (points.shape[-1]==3):
        return np.hstack([rotate_points(points[:,0:2],theta,center),points[:,2:]])
    else:
        if(points.shape[-1]!=2):
            raise Exception
    x,y=np.array(points[:,0]),np.array(points[:,1])
    cost=math.cos(theta)
    sint=math.sin(theta)
    x1=x*cost-y*sint + ty*sint - tx*(cost-1)
    y1=x*sint+y*cost - tx*sint - ty *(cost-1)
    return np.vstack((x1,y1)).T

def translate_points(x,offset=(0,0)):
    """returns translated coordinates of 2D point(s) x ([Npoints x 2]) by an offset."""
    points=np.matrix(x)
    x,y=np.array(points[:,0]),np.array(points[:,1])
    x1=x+offset[0]
    y1=y+offset[1]
    return np.hstack((x1,y1))

def get_points(filename,xrange=None,yrange=None,matrix=False,scale=(1.,1.,1.),center=(0,0,0)):
    """return a set of xyz points (Nx3) from nanovea saved txt (matrix=False)
    or gwyddion saved matrix (matrix=True, xrange, yrange must be defined).
    Scale is used to scale the """
    if (matrix):
        if (xrange==None or yrange==None): raise Exception
        mdata=np.genfromtxt(filename,skip_header).T
        nx,ny= mdata.shape
        x=np.linspace(*xrange,num=nx)
        y=np.linspace(*yrange,num=ny)
        #plt.imshow(mdata, extent=(mxrange.min(), myrange.max(), mxrange.max(), myrange.min()))
        xpoints,ypoints=[xy.flatten() for xy in np.array(np.meshgrid(x,y))]
        zpoints=mdata.flatten()
        points=np.vstack([xpoints,ypoints,zpoints])
    else:
        points= np.genfromtxt(filename,delimiter=',')
    
    points=points-np.hstack([((points.max(axis=0)-points.min(axis=0))/2)[0:2],0]) #center on 0
    points=points*scale
    return points

def save_points(filename,points,xgrid=None,ygrid=None,matrix=False,fill_value=0):
    """save points on a file. If matrix is true write in matrix form (in this case you have to 
    provide the values for axis). Otherwise write as points in columns."""
    if matrix:
        assert xgrid!=None
        assert ygrid!=None
        grid=np.vstack([g.flatten() for g in  np.meshgrid(xgrid,ygrid)]).T
        points=ip.griddata(points[:,0:2],points[:,2],grid,fill_value=fill_value)
        points=points.reshape(ygrid.size,xgrid.size)
        #points=np.hstack([grid,points[:,np.newaxis]])
    #if not, they are already in the correct format
    np.savetxt(filename,points)

def resample_points(tpoints,positions):
    """resample tpoints [Npoints x 3] on the points defined in positions [Mpoints x 2], or [Mpoints x 3]
    (in this case 3rd column is ignored).
    Return a [Nx x Ny , 3] vector of points. To get a (plottable) matrix of data use:
    plt.imshow(rpoints[:,2].reshape(xgrid.size,ygrid.size))."""
    assert tpoints.shape[1]==3
    z=ip.griddata(tpoints[:,0:2],tpoints[:,-1],positions[:,0:2])
    rpoints=np.hstack([positions[:,0:2],z[:,np.newaxis]])
    return rpoints
    
def plot_points(points,xgrid=None,ygrid=None,shape=None,resample=True,scatter=False,**kwargs):
    """resample xyz points [Nx3] to a grid whose axis xgrid and ygrid are given
    and plot it. If resample is set to False x and y positions are considered only for range, 
    but they are not used to position the z values (it works if x and y are on an exact unrotated grid,
    resampling is slower, but exact)."""
    
    def resample_grid(tpoints,xgrid,ygrid):
        from matplotlib.mlab import griddata
        """resample tpoints [Npoints x 2] on the grid defined by two vectors xgrid [Nx] and ygrid [Ny].
        Return a [Nx x Ny , 3] vector of points. To get a (plottable) matrix of data use:
        plt.imshow(rpoints[:,2].reshape(xgrid.size,ygrid.size))."""
        assert tpoints.shape[1]==3
        x,y=np.meshgrid(xgrid,ygrid)
        z=ip.griddata(tpoints[:,0:2],tpoints[:,2],(x,y))     
        rpoints=np.vstack([x.T.flatten(),y.T.flatten(),z.T.flatten()]).T
        return rpoints
    
    x,y,z=np.hsplit(points,3)
    if shape==None:
        assert len(xgrid.shape)==len(ygrid.shape)==1
    else:
        assert xgrid==ygrid==None
        xgrid=np.linspace(x.min(),x.max(),shape[0])
        ygrid=np.linspace(y.min(),y.max(),shape[1])
    if resample:
        print "resampling..."
        z=resample_grid(points,xgrid,ygrid)[:,2]
    
    z=z.reshape(xgrid.size,ygrid.size)
    #plot
    plt.clf()
    if scatter: #do scatterplot
        beamsize=100 #I may use this to represent beamsize (round symbol) or lateral resolution (square)
        plt.scatter(x, y, c=z, s=beamsize, cmap=plt.cm.cool, edgecolors='None')
    else:
        plt.imshow(z,extent=[ygrid.min(),ygrid.max(),xgrid.max(),xgrid.min()],aspect='auto',interpolation='none')
    plt.xlabel('Y (mm)')
    plt.ylabel('X (mm)')
    plt.colorbar()
    plt.show()


def crop_points(points, xrange=None,yrange=None):
    """crop a xyz points [Nx3], keeping only points inside xrange and yrange defined as (min,max)."""
    if xrange != None: 
        points=points[np.where(xrange[0]<points[:,0]),:][0]
        points=points[np.where(points[:,0]<xrange[1]),:][0]
    if yrange != None: 
        points=points[np.where(yrange[0]<points[:,1]),:][0]
        points=points[np.where(points[:,1]<yrange[1]),:][0]
    return points
    
def subtract_points(p1,p2,):
    """Subtract second set of points after interpolation on first set coordinates."""
    p2=resample_points(p2,p1)
    p1[:,2]=p1[:,2]-p2[:,2]
    return p1
    

